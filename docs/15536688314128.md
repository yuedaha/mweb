# Redis 知识整理

## Redis 和其他缓存的优势
Redis 除了 key-value 的形式的存储，它还支持多种数据类型

## Redis 为什么这么快
* 采用的是单线程操作，避免了线程切换的资源浪费
    * Redis 不依赖 cpu 的计算，它主要依赖的是内存和带宽，所以不需要采用多线程技术
* 采用多路复用技术

## Redis 的数据类型
* 字符型
    * 字符串、整形、浮点型
    * 整形原子递增
* 列表
    * 有序的双向链表
    * 可以做栈、消息队列
* 哈希
    * 可以存对象
    * session 解决方案
* 集合
    * 无序不重复
    * 用户标签，有交集、并集、差集
* 有序集合
    * 有序不重复，内部维护着 score 字段做排序
    * 查询 top 几，还有其他范围操作

## Redis 持久化策略
* RDB
    * 使用中快照的方式，根据配置，每隔一段时间就会将内存中的数据持久化到本地
    * 持久化方式是 fork 一个子进程，将内存数据写到临时文件中，持久化操作结束，将临时文件替换成上一次持久化的文件
    * 这种方式可能会丢失最后一次持久化之后的数据，由于是 fork 一个子进程，所以不会影响 redis 主进程的性能
* AOF
    * 是一种记录操作日志的方式，redis 服务在进行写操作后，会将操作指令记录到日志文件中
    * 当日志文件会越来越大，很多内容其实可以丢弃，达到设置的阈值时，会进行调整，就是将内存中的数据全部变成设置的指令，例如，字符串会变成 set 指令。
    * 这种方式会影响 redis 的主进程性能

## Redis 失效策略
* 消极方式
    * 在获取设置了失效时间的值的时候，查询是否已经失效，如果已经失效则删除
* 积极方式
    * 定时去拉取一部分（默认20条）设置了失效时间的数据
    * 判断这部分数据是否已经失效，如果失效则删除
    * 如果失效数据超过一定的阈值（默认25%），则再次拉取数据检查
    * 循环这个操作，直到失效数据占比小于阈值结束

## Redis 为什么要使用 Lua 脚本
* redis 无法保证一系列操作的原子性
    * redis 虽然是单线程操作，他只能保证单次操作的原子性
    * 例如：如果先获取 key 值，再根据 key 值操作，然后更新，如果在更新操作之前，redis 其他客户端对这个 key 值进行修改，就会出现数据错误
    * 如果使用 lua 脚本，将多个操作合并到一起，则 redis 可以保证操作的原子性
* 减少多次网络请求带来的资源浪费
    * 虽然 redis 的查询很快，但是如果多个操作，则需要发送多次请求，每次请求都会有网络开销，如果使用 lua 脚本，则只需要发送一次请求，减小资源开销
* redis 还可以复用 lua 脚本

## Redis 主从复制配置
* redis 主服务配置绑定的 ip
* redis 从服务配置 slaveof masterip masterport
* 可以通过`info replication`查看主从服务状态 

## Redis 主从复制数据同步方式
* 全量复制
    * 从服务第一次连接主服务时，主服务会生成 RDB 文件，并记录之后的所有操作，
    * 主服务将 RDB 文件发送给从服务，从服务进行数据恢复
    * 数据恢复结束后，将之后操作的记录发送给从服务，进行数据同步
    * 此方式异步进行，不影响主服务
* 增量复制
    * 
* 无磁盘复制

## Redis 哨兵机制

## Redis 集群

