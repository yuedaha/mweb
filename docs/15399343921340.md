# 线程同步

### 一、同步是什么

资源共享的两个原因是资源的紧缺和共建需求。线程共享CPU是从资源紧缺的维度来考虑的，而多线程的共享变量是从共建需求的维度考虑问题的。在多线程环境中，如果线程操作不是原子性的，则可能产出脏数据。

计算机的线程同步，就是线程之间按照某种机制协调先后执行顺序，当一个线程对内存操作是，其他线程不允许对改地址内存进行操作，直到该线程完成操作。实现线程同步的方式有很多，比如：同步方法、锁、阻塞队列等。

### 二、volatile

> happen before原则
> 指令重排

线程操作变量时，会将变量从主内存中复制一个副本放置在本地局部变量中，操作完成后再同步到主内存中，这样在多线程并发对同一个变量进行写操作是，会存在线程不安全的情况。

volatile可以解决变量的可见性。volatile会防止指令重排，每次修改volatile修饰的变量都会立刻同步到主内存中，每次使用volatile变量都会从主内存中读取。这样使得每次修改都会在读取之前。保证每次读取的变量值都是最新的值。

> 单例模式中，双重检查锁就可以使用volatile来修饰单例对象，防止出现指令重排导致的NPE。

volatile只能保证可见性，但不能保证互斥性，所以对volatile修饰的变量的操作无法保证原子性，也就无法解决多线程并发修改变量的线程安全问题。

> JDK8 推荐使用AtomicAddr来代替AtomicLong，它性能更好，有效的减少了乐观锁的重试次数。

volatile并不是轻量级的同步方式，他只是轻量级的线程操作可见方式，并非同步方式，在多写的场景下一定会发生线程安全问题。他只是和一写多读场景，CopyOnWriteArrayList是典型的使用方式。

### 三、信号量

信号量同步是指不同的线程之间，通过传递同步信号量来协调线程执行的先后顺序。由时间维度和信号维度来分析。

时间维度（CountDownLatch）：CountDownLatch是基于时间维度的，设置总的state，然后调用await()方法等待。每个子线程执行countDown()方法，将state减1，当state=0时，继续执行await()方法后的程序。

> 注意子线程报错时无法执行countDown()方法会导致程序一直在await()方法等待

信号量维度（Semphore）：可以做到并发数量控制，设置初始state，通过acquire()获取信号量，通过release()释放信号量。当state=0时，所有acquire()请求都会被阻塞。