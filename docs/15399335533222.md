# 垃圾回收（GC）

Java对内存进行自动分配和回收管理，使上层业务更加安全，方便的使用内存来实现程序逻辑。在不同的JVM实现及回收机制中，对堆内存的划分也不同。JVM的垃圾回收是回收不再使用的对象，自动释放内存。

为了判断哪些对象是不再使用的对象，JVM引入了GC Roots。如果一个对象和GC Roots之间没有直接引用或间接引用关系，例如某个失去任何引用的对象，或者两个对象之间循环引用。这些对象都是不再被使用的对象，会被GC回收。

可以被当做GC Roots的是：静态属性中引用的实例对象、常量引用的对象，虚拟机栈中所引用的对象，本地方法栈中所引用的对象。

### 垃圾回收算法

#### 1）标记-清除算法

每次从GC Roots出发，依次标记有引用关系的对象，最后清除没有被标记的对象。此算法会带来大量的空间碎片问题，当新增一个大对象时，可能会触发FGC。为了解决这个问题，引入了标记-整理算法。

#### 2）标记-整理算法

此算法类似于磁盘整理，首先从GC Roots开始，标记有引用关系的对象，将所有标记的对象移入内存的另外一端，形成连续的内存空间，最后把已用的内存空间清空。这样就不会产生内存碎片了。

#### 3）Mark-Copy算法

将内存分为小的片段，每次只激活某一些内存片段，GC时激活另外的内存片段，将存活的对象移入激活的内存片段中，将原来激活的内存片段清空，并置为未激活状态。

堆内存的年轻代就讲内存分为较大的Eden区和两个Survivor区，每次只激活一个Survivor区。现在主流的YGC算法都是采用Mark-Copy算法进行垃圾回收。

### GC回收器

GC回收器就是实现垃圾回收算法并应用在JVM中的内存管理模块。

#### 1）Serial回收器

Serial回收器主要是应用在YGC的垃圾回收器，采用的是单线程串行的方式回收，当进行垃圾回收时，会暂停应用程序，成为“Stop The Word”，简称STW。FGC停顿的时间更长。频繁的FGC会严重影响程序的性能。

#### 2）CMS回收器

CMS回收器是停顿时间比较短，目前最常用的垃圾回收器。它采用的是初始标记（Initial Mark）、并发标记（Concurrent Mark）、重新标记（Remark）、并发清除（Concurrent Sweep）这四个步骤来完成垃圾回收工作。在初始标记和重新标记阶段会存在STW，在并发标记和并发清楚阶段不会存在STW，是和应用程序并发执行的，也是比较耗时的操作，不会影响应用程序的正常运行。

但是，由于CMS回收器采用了“标记-清楚”算法，垃圾回收后，会存在内存片段问题，可以通过设置JVM运行时参数来控制每次FGC后，对老年代进行内存压缩，执行一次空间碎片的整理。设置参数为`-XX:+UseCMSCompactAtFullCollection`。空间碎片整理阶段回引发STW，可以通过设置JVM运行参数来控制对老年代空间压缩次数。参数为：`-XX:+CMSFullGCsBeforeCompaction=n`，n表示在执行n次FGC后才进行老年代控件压缩。

#### 3）G1回收器

jdk在1.7之后，推出了G1垃圾回收器，通过参数`-XX:+UseG1GC`来开启。它也具备空间压缩能力，避免空间碎片。相对与CMS回收器，他的暂停时间更可控。参数为`-XX:MaxGCPauseMillis=n`，n为停顿时间，性能总体来说还是很不错的。

G1回收器将内存划分为若干个相同大小的内存区域，成为region。包括Eden、Survivor、Old和Humongous，其中Humongous是特殊的Old类，用于存放大对象。这样设计的目的不需要一个连续的内存空间管理对象，每次GC时会优先回收垃圾较多的区域。G1采用的是“Mark-Copy”算法，有很好的空间整合能力，不会产生大量的空间碎片。G1的最大优势是可预测的停顿时间，会尽可能的在指定的时间内完成垃圾回收。在JDK11中，G1是默认的垃圾回收器。

G1回收器在YGC的时候，不会进行S0/S1的交换。在初始标记时依然会引发STW。