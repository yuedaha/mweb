# Redis内存回收

Redis的回收策略有两种，定期删除和惰性删除策略。

定期删除：用一个定时器来监控key值，过期之后删除
惰性删除：在每次获取key值的时候去判断是否过期，过期这删除

1、有了定期删除，为什么还要用惰性删除？
定期删除可以将内存很好的释放，但是会引来另一个问题，就是十分消耗CPU资源。在高并发请求下，CPU应该是应用在处理请求操作，而不是删除key操作。因此不能完全使用定期删除策略。

2、Redis中定期删除和惰性删除是如何工作的？

Redis默认每100ms检查一下是否有key值过期，过期则删除。但不是查询所有的key值，是随机抽样。这也会导致一些过期的key值无法被删除。此时在加上惰性删除策略一起，查询时再次判断是否过期，过期则删除。

采用定期删除和惰性删除之后还有没有其他问题？

还是会存在key值已经过期，但是没有被定期删除，也没有被使用到，导致一直存在内存中，导致内存堆积越来越大。此时则要采用内存的淘汰机制。在redis的配置文件中可以设置`maxmemory-policy volatile-lru`

**淘汰策略**

* noeviction（默认）: 当内存不足以容纳新写入数据时，新写入操作会报错

* allkeys-lru : 当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key**（推荐）**
* allkeys-random : 当内存不足以容纳新写入数据时，在键空间中，随机移除某个key

**已经设置过期的key**
* volatile-lru : 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key**（这种情况一般是把redis既当缓存，又做持久化存储的时候才用）**
* volatile-random : 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key
* volatile-ttl : 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除

> 如果没有设置 expire 的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。