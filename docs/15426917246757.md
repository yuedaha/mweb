# Redis总结

##### 1、为什么要用Redis？

> 分析：通过两方面考虑，性能和并发

**性能：**当遇到不经常变化的sql，可以将数据缓存到Redis中，减少数据库访问开销，使得请求能快速响应

**并发：**当高并发情况下，所有的请求都访问到了数据库，会导致连接异常情况。为了减少数据库的压力，将Redis作为缓冲层，先访问Redis，再访问数据库。



**为什么不用其他的KV存储，例如：Memcached,Cassandra等?**



##### 2、Redis有哪些缺点

引入Redis之后主要带来以下四个问题：

- 缓存和数据库双写一致性问题 
- 缓存雪崩问题
- 缓存击穿问题
- 缓存的并发竞争问题



##### 3、单线程Redis为什么这么快

Redis工作机制主要以下三个方面：

- 纯内存操作
- 单线程操作，避免了频繁的上下文切换
- 采用非阻塞式的**I/O多路复用**机制



##### 4、Redis的数据类型，每种数据类型的使用场景？

> 分析：zset是⼲什么的? 和set有什么区别?

五种数据类型：

- String
  - 常规set/get操作，value可以是字符串也可以是数字
  - 一般用作复杂的**计数功能**缓存
- hash
  - value是机构化的对象，比较方便操作其中的某个字段
  - 可做**单点登录**存放用户信息，设置key的过期时间30分钟，可模拟session效果
- list
  - 使用list结构
  - 可以做消息队列功能
  - 可以用`lrange`命令，用作基于redis的**分页功能**
- set
  - 存放的是不重复的集合
  - 可以做全局去重的功能（如果系统为分布式系统，使用jvm自带set会比较麻烦）
  - 运用交集、并集、差集等操作，可以计算**共同喜好**、**全部喜好**、**自己独有喜好**
- sorted set
  - 多一个权重的score，集合元素可以按照score排序
  - 可以用作**排名榜应用**，取**TOP N**操作
  - 可以做**延迟任务**
  - 可以做**范围查找**




##### 6、缓存雪崩、缓存穿透可以介绍一下么？你认为应该如何解决这个问题？

**缓存雪崩**：同一时间，缓存大面积失效，请求全部落到数据库，导致数据库连接异常。

- ***缓存的过期时间随机设置***，避免同一时间存在大量过期
- ***加互斥锁，吞吐量会明显下降***
- 采用***多级缓存***，例如：缓存A设置过期时间20分钟，缓存B不设置过期时间
  - 从缓存A中读取数据，有则返回
  - 缓存A中没有数据，直接从缓存B中读取缓存，直接返回。异步启动一个更新线程
  - 更新线程同时更新缓存A和缓存B

**缓存穿透**：大量的访问的key不存在，缓存命中率低的令人发指。请求全部落到数据库，导致数据库连接异常

- 设置互斥锁，缓存失效的时候先去获得锁，然后再去访问数据库。没有获得锁的先休眠一段时间，然后再尝试获得锁。**（可以控制数据库的连接数，做限流）**
- ***对空值缓存，可以设置特殊字符value。一段时间内的请求可以阻挡。***
- ***采用异步更新策略***，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做**缓存预热**(项目启动前，先加载缓存)操作
- 提供一个快速判断请求的key是否有效的拦截机制。可以设置key的规则，也可以采用**布隆过滤器**。不符合规则的key直接返回
  - **布隆过滤器**
    - 空间效率非常高的概率性算法，bitmap和hash标记
    - 存在误判
    - guava内提供了BloomFilter的API



##### 7、redis和数据库双写一致性问题

> **分析：**一致性问题是分布式常见问题，分为**强一致性**和**最终一致性**。强一致性的数据不能放入缓存。我们所做的一切方案只是为了保证最终一致性。此外，我们的方案从根本上来说，只能降低数据不一致性的可能性，不能完全避免。

- 强一致性数据不写入缓存
- 先更新数据库，再删除缓存
  - 删除缓存可能失败，***补偿机制可以采用消息队列***



##### 8、如何解决redis的并发竞争key问题

> **分析：**当多个子系统去set同一个key，此时会出现竞争问题。redis支持事务，但是如果redis采用分片方式，一个事务设计多个key在不同区域，***此时事务会很难做***。

1）如果对这个key操作，不要求顺序，可以做一个分布式锁，大家争抢锁，抢到锁就可以执行。方法简单

2）如果对这个key操作，要求顺序，可以对需要设置的数据加一个时间戳，依然做一个分布式锁。

- 系统A设置value1，系统B设置value2，系统C设置value3。期望顺序为value1->value2->value3，最终key的值改为value3
- 每个系统在自己的值上增加时间戳，获取锁的时候，检查当前key的值的时间戳是否大于自己的时间戳，如果大于，则不执行，直接返回。否则，执行set操作。

> 系统A key 1 {valueA  3:00}
> 系统B key 1 {valueB  3:05}
> 系统C key 1 {valueC  3:10}

3）也可以采用队列，讲set操作变成串行的